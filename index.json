[{"categories":["文档"],"content":"一个多线程的问题，用三个线程，顺序打印字母A-Z，输出结果是1A 2B 3C 1D 2E…打印完毕最后输出一个Ok。 public class Test { private static char c = 'A'; private static int i = 0; public static void main(String[] args) { Runnable r = new Runnable() { @Override public void run() { synchronized (this) { try { int id = Integer.parseInt(Thread.currentThread().getName()); while (i \u003c 26) { if (i % 3 == id - 1) { System.out.println(\"线程id：\" + id + \" \" + (char) c++); i++; notifyAll(); } else { wait(); } } } catch (Exception e) { e.printStackTrace(); } } } }; new Thread(r, \"1\").start(); new Thread(r, \"2\").start(); new Thread(r, \"3\").start(); } } 每个线程把自己的ID在屏幕上打印10遍，要求输出结果必须按ABC的顺序显示 LockSupport public class Main { static Thread threadA, threadB, threadC; public static void main(String[] args) { threadA = new Thread(() -\u003e { for (int i = 0; i \u003c 10; i++) { System.out.print(Thread.currentThread().getName()); LockSupport.unpark(threadB); LockSupport.park(); } }, \"A\"); threadB = new Thread(() -\u003e { for (int i = 0; i \u003c 10; i++) { System.out.print(Thread.currentThread().getName()); LockSupport.unpark(threadC); LockSupport.park(); } }, \"B\"); threadC = new Thread(() -\u003e { for (int i = 0; i \u003c 10; i++) { System.out.print(Thread.currentThread().getName()); LockSupport.unpark(threadA); LockSupport.park(); } }, \"C\"); threadA.start(); threadB.start(); threadC.start(); } } ReentrantLock import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { public static void main(String[] args) { ReentrantLock lock = new ReentrantLock(); Condition conA = lock.newCondition(); Condition conB = lock.newCondition(); Condition conC = lock.newCondition(); // A new Thread(() -\u003e { try { lock.lock(); for (int i = 0; i \u003c 10; i++) { System.out.print(Thread.currentThread().getName()); conB.signal(); conA.await(); } conB.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } }, \"A\").start(); // B new Thread(() -\u003e { try { lock.lock(); for (int i = 0; i \u003c 10; i++) { System.out.print(Thread.currentThread().getName()); conC.signal(); conB.await(); } conC.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } }, \"B\").start(); // C new Thread(() -\u003e { try { lock.lock(); for (int i = 0; i \u003c 10; i++) { System.out.print(Thread.currentThread().getName()); conA.signal(); conC.await(); } conA.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } }, \"C\").start(); } } 两线程奇偶数打印 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { static int value = 0; public static void main(String[] args) { ReentrantLock lock = new ReentrantLock(); Condition conA = lock.newCondition(); Condition conB = lock.newCondition(); // A new Thread(() -\u003e { try { lock.lock(); while (value \u003c= 100) { System.out.println(Thread.currentThread().getName() + \" \" + value++); conB.signal(); conA.await(); } conB.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } }, \"A\").start(); // B new Thread(() -\u003e { try { lock.lock(); while (value \u003c= 100) { System.out.println(Thread.currentThread().getName() + \" \" + value++); conA.signal(); conB.await(); } conA.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } }, \"B\").start(); } } 启动3个线程打印递增的数字, 线程1先打印1,2,3,4,5, 然后是线程2打印6,7,8,9,10。直到75 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { static int value = 1; public static void main(String[] args) { ReentrantLock lock = new ReentrantLock(); Condition conA = lock.newCondition(); Condition conB = lock.newCondition(); // A new Thread(() -\u003e { try { lock.lock(); while (value \u003c= 75) { System.out.print(Thread.currentThread().getName() + \" \"); for (int i = 0; i \u003c 5; i++) { System.out.print(value++ + \" \"); } System.out.println(\"\"); conB.signal(); conA.await(); } conB.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } }, \"A\").start(); // B ne","date":"2021-06-26","objectID":"/thread/:0:0","tags":["笔试"],"title":"多线程编程","uri":"/thread/"},{"categories":["documentation"],"content":"创建数据库并制定编码 Createdatabase数据库名defaultcharactersetutf8;Createdatabasessmdefaultcharactersetutf8; ","date":"2021-06-09","objectID":"/sql/:0:1","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"删除数据库 dropdatabase数据名;dropdatabasessm; ","date":"2021-06-09","objectID":"/sql/:0:2","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"创建表 一般情况： Createtable表名(列名类型约束auto_incrementcomment'备注';);createtablieflower(idint(10)primarykeyauto_incrementcomment'编号',namevarchar(30)notnullcomment'花名',pricefloatnotnullcomment'价格',productionvarchar(30)notnullcomment'原产地');createtablieflower(`id`int(10)notnullauto_incrementcomment'编号',`name`varchar(30)notnullcomment'花名',`price`floatnotnullcomment'价格',`production`varchar(30)notnullcomment'原产地',primarykey(`id`)); ","date":"2021-06-09","objectID":"/sql/:0:3","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"插入信息 insertinto表明(姓名，性别，年龄)values('李一','女','18');insertinto`flower`(`id`,`name`,`price`,`production`)values(defalut,'矮牵牛',2.5,'南美阿根廷') ","date":"2021-06-09","objectID":"/sql/:0:4","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"查询信息 select*from表名;select*fromflower;select*from表名whereID=5select*fromflowerwhereID=1 ","date":"2021-06-09","objectID":"/sql/:0:5","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"更新信息 update表名setname='李一'wherename='王五';updateflowersetprice=1.2whereid=1; ","date":"2021-06-09","objectID":"/sql/:0:6","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"删除信息 deletefrom表名whereid=1;deletefromflowerwhereid=1; ","date":"2021-06-09","objectID":"/sql/:0:7","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"删除表 droptable表名;droptableflower; ","date":"2021-06-09","objectID":"/sql/:0:8","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"查看表信息 desc表名;descflower; ","date":"2021-06-09","objectID":"/sql/:0:9","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"一对多关系 可能是写的不熟练吧，所以要做个笔记，以免之后再次忘掉。 例子：假如有这样的一对多关系，首先有一个User模型，其中该模型有id、name和gender字段。还有一个Artical模型，其中该模型有id、title、content和user_id字段，而user_id则是外键。如下图： 那么在mysql或者mysql的一些工具下创建输入以下代码： createdatabasedemodefaultcharactersetutf8;-- 创建数据库 usedemo;-- 创建user表格 createtableuser(`id`int(10)notnullauto_incrementcomment'编号',`name`varchar(16)notnullcomment'姓名',`gender`varchar(4)notnullcomment'性别',primarykey(`id`));-- 创建artical createtableartical(`id`int(10)notnullauto_incrementcomment'文章编号',`title`varchar(32)notnullcomment'标题',`content`textdefaultnullcomment'内容',`user_id`int(10)notnullcomment'用户编号',primarykey(`id`),key(`user_id`),constraint`artical_idfk_1`foreignkey(`user_id`)references`user`(`id`)-- 这句话非常重要 constraint ··· 约束 );-- 在user中插入数据 insertintouser(`id`,`name`,`gender`)values(default,'Maifeng','男');insertintouser(`id`,`name`,`gender`)values(default,'Liumeng','女');-- 在artical中插入数据 insertinto`artical`(`id`,`title`,`content`,`user_id`)values(default,'我是mm','null',1);insertinto`artical`(`id`,`title`,`content`,`user_id`)values(default,'我是xxx','null',2); 如下图user和artical表 ","date":"2021-06-09","objectID":"/sql/:0:10","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"更改auto_increment altertable表名auto_increment=5;altertableflowerauto_increment=5; ","date":"2021-06-09","objectID":"/sql/:0:11","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"常用sql语句 数据库 # 查看所有数据库 showdatabases;# 创建一个数据库 createdatabasedemo;# 删除一个数据库 dropdababasedemo;# 使用这个数据库 usedemo; 表 # 查看所有的表 showtables;# 创建一个表 createtablen(`id`int,`name`varchar(10));createtablem(`id`int,`name`varchar(10),primarykey(`id`),foreignkey(`id`)referencesn(`id`),unique);createtablem(`id`int,`name`varchar(10));# 直接将查询结果导入或复制到新创建的表 createtablenselect*fromm;# 将创建的表与一个存在的表的数据结构类似 createtablemliken;# 创建一个临时表 # 临时表将在你连接MySQL期间存在。当断开连接时，MySQL将自动删除表并释放所用的空间。也可手动删除。 createtemporarytablel(`id`int,namevarchar(10));# 直接将查询结果导入或复制到新的临时表 createtemporarytablettselect*fromn;# 删除一个已经存在的表 droptableifexistsm;# 更改存在表的名称 altertablenrenamem;renametablentom;# 查看表的结构(5种,效果相同) descn;describen;showcolumnsinn;showcolumnsfromn;explainn;# 查看表的创建语句 showcreatetablen; 表的结构 # 添加字段 altertablenaddagevarchar(2);# 删除字段 altertablendropage;# 更改字段属性和属性 altertablenchangeageaint;# 只更改字段属性 altertablenmodifyagevarchar(7); 表的数据 # 增加数据 insertintonvalues(1,'tom','23'),(2,'john','22');insertintonselect*fromn;# 把数据复制一遍重新插入 # 删除数据 deletefromnwhereid=2;# 更改数据 updatensetname='tom'whereid=2;# 数据查找 select*fromnwherenamelike'%h%';# 数据排序(反序) select*fromnorderbyname,iddesc; 键 # 添加主键 altertablenaddprimarykey(id);# 删除主键 altertablendropprimarykey;# 添加外键 altertablemaddforeignkey(id)referencesn(id);# 自动生成键名m_ibfk_1 # 自定义名称的外键 altertablemaddconstraintfk_idforeignkey(id)referencesn(id);# 删除外键 altertablemdropforeignkey`fk_id`;# 修改外键 altertablemdropforeignkey`fk_id`,addconstraintfk_id2foreignkey(id)referencesn(id);# 添加唯一键 altertablenaddunique(name);altertablenadduniqueu_name(name);altertablenadduniqueindexu_name(name);altertablenaddconstraintu_nameunique(name);createuniqueindexu_nameonn(name);# 添加索引 altertablenaddindex(age);altertablenaddindexi_age(age);createindexi_ageonn(age);# 删除索引或唯一键 dropindexu_nameonn;dropindexi_ageonn; 视图 # 创建视图 createviewvasselectid,namefromn;createviewv(id,name)asselectid,namefromn;# 查看视图(与表操作类似) select*fromv;descv;# 查看视图语句 showcreateviewv;# 更改视图 CREATEORREPLACEVIEWvASSELECTname,ageFROMn;ALTERVIEWvASSELECTnameFROMn;# 删除视图 dropviewifexistsv; 联接 # 内联接 select*fromminnerjoinnonm.id=n.id;# 左外连接 select*frommleftjoinnonm.id=n.id;# 右外连接 select*frommrightjoinnonm.id=n.id;# 交叉连接 select*frommcrossjoinn;# 标准写法 select*fromm,n;# 类似于全连接full join 的联接用法 selectid,namefrommunionselectid,namefromn 函数 # 聚合函数 selectcount(id)astotalfromn;# 总数 selectsum(age)asall_agefromn;# 总和 selectavg(age)asall_agefromn;# 平均值 selectmax(age)asall_agefromn;# 最大值 selectmin(age)asall_agefromn;# 最小值 # 数学函数 selectabs(-5);# 绝对值 selectbin(15),oct(15),hex(15);# 二进制，八进制，十六进制 SELECTpi();# 圆周率3.141593 SELECTceil(5.5);# 大于x的最小整数值6 SELECTfloor(5.5);# 小于x的最大整数值5 SELECTgreatest(3,1,4,1,5,9,2,6);# 返回集合中最大的值9 SELECTleast(3,1,4,1,5,9,2,6);# 返回集合中最小的值1 SELECTmod(5,3);# 余数2 SELECTrand();# 返回０到１内的随机值，每次不一样 SELECTrand(5);# 提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。 SELECTround(1415.1415);# 四舍五入1415 SELECTround(1415.1415,3);# 四舍五入三位数1415.142 SELECTround(1415.1415,-1);# 四舍五入整数位数1420 SELECTtruncate(1415.1415,3);# 截短为3位小数1415.141 SELECTtruncate(1415.1415,-1);# 截短为-1位小数1410 SELECTsign(-5);# 符号的值负数-1 SELECTsign(5);# 符号的值正数1 SELECTsqrt(9);# 平方根3 SELECTsqrt(9);# 平方根3 # 字符串函数 SELECTconcat('a','p','p','le');# 连接字符串-apple SELECTconcat_ws(',','a','p','p','le');# 连接用','分割字符串-a,p,p,le SELECTinsert('chinese',3,2,'IN');# 将字符串'chinese'从3位置开始的2个字符替换为'IN'-chINese SELECTleft('chinese',4);# 返回字符串'chinese'左边的4个字符-chin SELECTright('chinese',3);# 返回字符串'chinese'右边的3个字符-ese SELECTsubstring('chinese',3);# 返回字符串'chinese'第三个字符之后的子字符串-inese SELECTsubstring('chinese',-3);# 返回字符串'chinese'倒数第三个字符之后的子字符串-ese SELECTsubstring('chinese',3,2);# 返回字符串'chinese'第三个字符之后的两个字符-in SELECTtrim(' chinese ');# 切割字符串' chinese '两边的空字符-'chinese' SELECTltrim(' chinese ');# 切割字符串' chinese '两边的空字符-'chinese ' SELECTrtrim(' chinese ');# 切割字符串' chinese '两边的空字符-' chinese' SELECTrepeat('boy',3);# 重复字符'boy'三次-'boyboyboy' SELECTreverse('chinese');# 反向排序-'esenihc' SELECTlength('chinese');# 返回字符串的长度-7 SELECTupper('chINese'),lower('chINese');# 大写小写 CHINESE chinese SELECTucase('chINese'),lcase","date":"2021-06-09","objectID":"/sql/:0:12","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"小破站学习的mysql 美女老师 sql表 先贴sql CREATETABLE`t_user`(`id`int(11)unsignedNOTNULLAUTO_INCREMENT,`user_name`varchar(50)CHARACTERSETutf8mb4COLLATEutf8mb4_general_ciNOTNULLDEFAULT''COMMENT'账户',`password`varchar(50)COLLATEutf8mb4_general_ciNOTNULLDEFAULT''COMMENT'密码',`gender`varchar(11)COLLATEutf8mb4_general_ciNOTNULLDEFAULT'',`age`int(11)NOTNULL,PRIMARYKEY(`id`))ENGINE=InnoDBAUTO_INCREMENT=8DEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_general_ci;INSERTINTO`t_user`(`id`,`user_name`,`password`,`gender`,`age`)VALUES(1,'abc','123','0',20),(2,'a','123','0',20),(3,'b','123','1',21),(4,'c','123','0',22),(5,'dae','123','1',23),(6,'e','123','0',24),(7,'f','123','0',25); ","date":"2021-06-09","objectID":"/sql/:0:13","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"基础查询 /* 语法： select 查询列表 from 表明； 特点： 1. 查询列表可以是：表中的字段、常量值、表达式、函数 2. 查询的结构是一个虚拟的表格 *//* 别名 ①便于理解 ②如果要查询的字段有重名的情况，使用别名可以区分开来 */#+号的作用/* select 100+90; 两个操作数都为数值型，则做加法运算 select '123'+90;只要其中一方为字符型，试图将字符型数值转换成数值型 如果转换成功，则继续做加法运算 select 'john'+90; 如果转换失败，则将字符型数值转换成0 select null+10; 只要其中一方为null，则结果肯定为null */#题目#1.下面的语句是否可以执行成功:能SELECTlast_name,job_id,salaryASsalFROMemployees;#2.下面的语句是否可以执行成功：能SELECT*FROMemployees;#3.找出下面语句中的错误：有个中文标点符号SELECTemployee_id,last_name,salary*12AS\"ANNUAL SALARY\"FROMemployees;#4.显示表departments的结构，并查询其中的全部数据DESCdepartments;SELECT*FROMdepartments;#5.显示出表employees中的全部job_id（不能重复）SELECTDISTINCTjob_idFROMemployees; ","date":"2021-06-09","objectID":"/sql/:0:14","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"条件查询 #2:条件查询/* 语法： select 查询列表 from 表名 where 筛选条件; 分类： 一、按条件表达式筛选 简单条件运算符：\u003e \u003c = != \u003c\u003e \u003e= \u003c= 二、按逻辑表达式筛选 逻辑运算符： 作用：用于连接条件表达式 \u0026\u0026 || ! and or not \u0026\u0026和and：两个条件都为true，结果为true，反之为false ||或or： 只要有一个条件为true，结果为true，反之为false !或not： 如果连接的条件本身为false，结果为true，反之为false 三、模糊查询 like between and in is null */#1.查询年龄大于22的用户信息SELECT*FROM`t_user`WHERE`age`\u003e22;#2.查询年龄不等于22的用户和密码SELECT`user_name`,`password`FROM`t_user`WHERE`age`\u003c\u003e20;#查询年龄在21到23之间的用户名和密码SELECT`user_name`,`password`FROM`t_user`WHERE`age`\u003e=21AND`age`\u003c=23;SELECT`user_name`,`password`,`age`FROM`t_user`WHERE`age`BETWEEN21AND23;#查询年龄21和23的用户名和密码SELECT`user_name`,`password`FROM`t_user`WHERE`age`IN(21,23);#模糊查询like/* 特点： ①一般和通配符搭配使用 通配符： % 任意多个字符,包含0个字符 _ 任意单个字符 */#查询用户名包字符a的用户信息SELECT*FROM`t_user`WHERE`user_name`LIKE'%a%';SELECT*FROM`t_user`WHERE`user_name`LIKE'_a%'; ","date":"2021-06-09","objectID":"/sql/:0:15","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"排序查询 /* 排序 select 查询列表 from 表 order by 排序列表 asc|desc. asc:升序，desc降序 可以放单个字段，也可以放多个字段，可以表达式，也可以放函数 order by 放最后 除limit语句 */题目：#1.查询员工的姓名和部门号和年薪，按年薪降序按姓名升序SELECTlast_name,department_id,salary*12*(1+IFNULL(commission_pct,0))年薪FROMemployeesORDERBY年薪DESC,last_nameASC;#2.选择工资不在8000到17000的员工的姓名和工资，按工资降序SELECTlast_name,salaryFROMemployeesWHEREsalaryNOTBETWEEN8000AND17000ORDERBYsalaryDESC;#3.查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序SELECT*,LENGTH(email)FROMemployeesWHEREemailLIKE'%e%'ORDERBYLENGTH(email)DESC,department_idASC; ","date":"2021-06-09","objectID":"/sql/:0:16","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"常见函数 /* 概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名 好处：1、隐藏了实现细节 2、提高代码的重用性 调用：select 函数名(实参列表) 【from 表】; 特点： ①叫什么（函数名） ②干什么（函数功能） 分类： 1、单行函数 如 concat、length、ifnull等 2、分组函数 功能：做统计使用，又称为统计函数、聚合函数、组函数 常见函数： 一、单行函数 字符函数： length:获取字节个数(utf-8一个汉字代表3个字节,gbk为2个字节) concat substr instr trim upper lower lpad rpad replace 数学函数： round ceil floor truncate mod 日期函数： now curdate curtime year month monthname day hour minute second str_to_date date_format 其他函数： version database user 控制函数 if case */#1.字符函数SELECTLENGTH('join');SELECTLENGTH('张三丰hahaha');SHOWVARIABLESLIKE'%char%';#2.拼接字符串SELECTCONCAT(`user_name`,'_',`password`)infosFROMt_user;#3.upper、lowerSELECTUPPER('john');SELECTLOWER('joHn');#示例：将姓变大写，名变小写，然后拼接SELECTCONCAT(UPPER(`user_name`),LOWER(`user_name`))infosFROMt_user;#4.substr、substring#注意：索引从1开始#截取从指定索引处后面所有字符SELECTSUBSTR('我是dreamcat',7)out_put;#截取从指定索引处指定字符长度的字符SELECTSUBSTR('我是dreamcat',1,3)out_put;SELECTCONCAT(UPPER(SUBSTR(`user_name`,1,1)),'_',LOWER(SUBSTR(`user_name`,2)))out_putFROMt_user;#5.instr返回子串第一次出现的索引，如果找不到返回0SELECTINSTR('我是dreamcat','dream')out_put;#6.trimSELECTLENGTH(TRIM(' dreamcat. '))out_put;SELECTTRIM('aa'FROM'aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')ASout_put;#7.lpad用指定的字符实现左填充指定长度SELECTLPAD('殷素素',5,'*')ASout_put;#8.rpad用指定的字符实现右填充指定长度SELECTRPAD('殷素素',12,'ab')ASout_put;#9.replace替换SELECTREPLACE('周芷若周芷若周芷若周芷若张无忌爱上了周芷若','周芷若','赵敏')ASout_put;#二、数学函数#round四舍五入SELECTROUND(-1.55);SELECTROUND(1.567,2);#ceil向上取整,返回\u003e=该参数的最小整数SELECTCEIL(-1.02);SELECTCEIL(1.02);#floor向下取整，返回\u003c=该参数的最大整数SELECTFLOOR(-9.99);SELECTFLOOR(9.99);#truncate截断SELECTTRUNCATE(1.69999,1);#mod取余SELECTMOD(10,-3);SELECT10%3;#三、日期函数#now返回当前系统日期+时间SELECTNOW();#curdate返回当前系统日期，不包含时间SELECTCURDATE();#curtime返回当前时间，不包含日期SELECTCURTIME();#可以获取指定的部分，年、月、日、小时、分钟、秒SELECTYEAR(NOW())年;SELECTYEAR('1998-1-1')年;SELECTMONTH(NOW())月;SELECTMONTHNAME(NOW())月;#str_to_date将字符通过指定的格式转换成日期SELECTSTR_TO_DATE('1998-3-2','%Y-%c-%d')ASout_put;#date_format将日期转换成字符SELECTDATE_FORMAT(NOW(),'%y年%m月%d日')ASout_put;#四、其他函数SELECTVERSION();SELECTDATABASE();SELECTUSER();#五、流程控制函数#1.if函数：ifelse的效果SELECTIF(10\u003c5,'大','小');SELECT*,IF(`age`\u003c24,'young','old')'new age'FROMt_user;#2.case函数的使用一：switchcase的效果/* java中 switch(变量或表达式){ case 常量1：语句1;break; ... default:语句n;break; } mysql中 case 要判断的字段或表达式 when 常量1 then 要显示的值1或语句1; when 常量2 then 要显示的值2或语句2; ... else 要显示的值n或语句n; end */SELECT*,CASE`age`WHEN21THEN21+1WHEN22THEN22+2WHEN23THEN23+3ELSEageEND'NEW age'FROMt_user;题目：#1.显示系统时间(注：日期+时间)SELECTNOW();#2.查询员工号，姓名，工资，以及工资提高百分之20%后的结果（newsalary）SELECTemployee_id,last_name,salary,salary*1.2'new salary'FROMemployees;#3.将员工的姓名按首字母排序，并写出姓名的长度（length）SELECTLENGTH(last_name)长度,SUBSTR(last_name,1,1)首字母,last_nameFROMemployeesORDERBY首字母;#4.做一个查询，产生下面的结果#\u003clast_name\u003eearns\u003csalary\u003emonthlybutwants\u003csalary*3\u003e#DreamSalary#Kingearns24000monthlybutwants72000SELECTCONCAT(last_name,' earns ',salary,' monthly but wants ',salary*3)AS'Dream Salary'FROMemployeesWHEREsalary=24000; ","date":"2021-06-09","objectID":"/sql/:0:17","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"分组函数 #二、分组函数/* 功能：用作统计使用，又称为聚合函数或统计函数或组函数 分类： sum 求和、avg 平均值、max 最大值 、min 最小值 、count 计算个数 特点： 1、sum、avg一般用于处理数值型 max、min、count可以处理任何类型 2、以上分组函数都忽略null值 3、可以和distinct搭配实现去重的运算 4、count函数的单独介绍 一般使用count(*)用作统计行数 5、和分组函数一同查询的字段要求是group by后的字段 */#1、简单的使用SELECTSUM(age)FROMt_user;SELECTAVG(age)FROMt_user;SELECTMIN(age)FROMt_user;SELECTMAX(age)FROMt_user;SELECTCOUNT(age)FROMt_user;SELECTSUM(user_name)FROMt_user;SELECTAVG(user_name)FROMt_user;SELECTCOUNT(user_name)FROMt_user;SELECTSUM(DISTINCTpassword)FROMt_user;SELECTCOUNT(DISTINCTpassword)FROMt_user;SELECTCOUNT(*)FROMt_user;SELECTCOUNT(1)FROMt_user; ","date":"2021-06-09","objectID":"/sql/:0:18","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"分组查询 #进阶5：分组查询/* 语法： select 查询列表 from 表 【where 筛选条件】 group by 分组的字段 【order by 排序的字段】; 特点： 1、和分组函数一同查询的字段必须是group by后出现的字段 2、筛选分为两类：分组前筛选和分组后筛选 针对的表 位置 连接的关键字 分组前筛选 原始表 group by前 where 分组后筛选 group by后的结果集 group by后 having 问题1：分组函数做筛选能不能放在where后面 答：不能 问题2：where——group by——having 一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率 3、分组可以按单个字段也可以按多个字段 4、可以搭配着排序使用 */SELECTCOUNT(*)FROMt_userWHEREpassword='123';SELECTAVG(age),passwordFROMt_userGROUPBYpassword;SELECTAVG(age),genderFROMt_userGROUPBYgender;题目：#1.查询各job_id的员工工资的最大值，最小值，平均值，总和，并按job_id升序SELECTMAX(salary),MIN(salary),AVG(salary),SUM(salary)FROMemployeesGROUPBYjob_idORDERBYjob_id;#2.查询员工最高工资和最低工资的差距（DIFFERENCE）SELECTMAX(salary)-MIN(salary)ASDIFFERENCEFROMemployees;#3.查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内SELECTMIN(salary),manager_idFROMemployeesWHEREmanager_idISNOTNULLGROUPBYmanager_idHAVINGMIN(salary)\u003e=6000;#4.查询所有部门的编号，员工数量和工资平均值,并按平均工资降序SELECTdepartment_id,COUNT(*),AVG(salary)FROMemployeesGROUPBYdepartment_idORDERBYAVG(salary)DESC;#5.选择具有各个job_id的员工人数SELECTCOUNT(*),job_idFROMemployeesGROUPBYjob_id; ","date":"2021-06-09","objectID":"/sql/:0:19","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"连接查询 #进阶6：连接查询/* 含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询 笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行 发生原因：没有有效的连接条件 如何避免：添加有效的连接条件 分类： 按年代分类： sql92标准:仅仅支持内连接 sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接 按功能分类： 内连接： 等值连接 非等值连接 自连接 外连接： 左外连接 右外连接 全外连接 交叉连接 */#1.显示所有员工的姓名，部门号和部门名称。SELECTe.last_name,d.department_id,d.department_nameFROMemployeese,departmentsdWHEREe.department_id=d.department_id;#2.查询90号部门员工的job_id和90号部门的location_idSELECTe.job_id,d.location_idFROMemployeese,departmentsdWHEREe.department_id=d.department_idANDe.department_id=90;#3.选择所有有奖金的员工的last_name,department_name,location_id,citySELECTlast_name,department_name,l.location_id,cityFROMemployeese,departmentsd,locationslWHEREe.department_id=d.department_idANDd.location_id=l.location_idANDe.commission_pctISNOTNULL;#4.选择city在Toronto工作的员工的last_name,job_id,department_id,department_nameSELECTe.last_name,e.job_id,e.department_id,d.department_nameFROMemployeese,departmentsd,locationslWHEREe.department_id=d.department_idANDd.location_id=l.location_idANDl.city='Toronto';#5.查询每个工种、每个部门的部门名、工种名和最低工资SELECTd.department_name,j.job_title,MIN(e.salary)FROMemployeese,departmentsd,jobsjWHEREe.department_id=d.department_idANDe.job_id=j.job_idGROUPBYd.department_name,j.job_title;#6.查询每个国家下的部门个数大于2的国家编号SELECTl.country_id,COUNT(*)FROMlocationsl,departmentsdWHEREd.location_id=l.location_idGROUPBYcountry_idHAVINGCOUNT(*)\u003e2;#7、选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式SELECTe.last_nameemployees,e.employee_id\"Emp#\",m.last_namemanager,m.employee_id\"Mgr#\"FROMemployeese,employeesmWHEREe.manager_id=m.employee_idANDe.last_name='kochhar';#二、sql99语法/* 语法： select 查询列表 from 表1 别名 【连接类型】 join 表2 别名 on 连接条件 【where 筛选条件】 【group by 分组】 【having 筛选条件】 【order by 排序列表】 分类： 内连接（★）：inner 外连接 左外(★):left 【outer】 右外(★)：right 【outer】 全外：full【outer】 交叉连接：cross */#一）内连接/* 语法： select 查询列表 from 表1 别名 inner join 表2 别名 on 连接条件; 分类： 等值 非等值 自连接 特点： ①添加排序、分组、筛选 ②inner可以省略 ③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读 ④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集 */#二、外连接/* 应用场景：用于查询一个表中有，另一个表没有的记录 特点： 1、外连接的查询结果为主表中的所有记录 如果从表中有和它匹配的，则显示匹配的值 如果从表中没有和它匹配的，则显示null 外连接查询结果=内连接结果+主表中有而从表没有的记录 2、左外连接，left join左边的是主表 右外连接，right join右边的是主表 3、左外和右外交换两个表的顺序，可以实现同样的效果 4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的 */ ","date":"2021-06-09","objectID":"/sql/:0:20","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"子查询 #进阶7：子查询/* 含义： 出现在其他语句中的select语句，称为子查询或内查询 外部的查询语句，称为主查询或外查询 分类： 按子查询出现的位置： select后面： 仅仅支持标量子查询 from后面： 支持表子查询 where或having后面：★ 标量子查询（单行） √ 列子查询 （多行） √ 行子查询 exists后面（相关子查询） 表子查询 按结果集的行列数不同： 标量子查询（结果集只有一行一列） 列子查询（结果集只有一列多行） 行子查询（结果集有一行多列） 表子查询（结果集一般为多行多列） */#一、where或having后面/* 1、标量子查询（单行子查询） 2、列子查询（多行子查询） 3、行子查询（多列多行） 特点： ①子查询放在小括号内 ②子查询一般放在条件的右侧 ③标量子查询，一般搭配着单行操作符使用 \u003e \u003c \u003e= \u003c= = \u003c\u003e 列子查询，一般搭配着多行操作符使用 in、any/some、all ④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果 */ ","date":"2021-06-09","objectID":"/sql/:0:21","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"分页查询 #进阶8：分页查询★/* 应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求 语法： select 查询列表 from 表 【join type join 表2 on 连接条件 where 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序的字段】 limit 【offset,】size; offset要显示条目的起始索引（起始索引从0开始） size 要显示的条目个数 特点： ①limit语句放在查询语句的最后 ②公式 要显示的页数 page，每页的条目数size select 查询列表 from 表 limit (page-1)*size,size; size=10 page 1 0 2 10 3 20 */ ","date":"2021-06-09","objectID":"/sql/:0:22","tags":["mysql"],"title":"常用mysql语句汇总","uri":"/sql/"},{"categories":["documentation"],"content":"Filechannel 源码分析.","date":"2021-06-07","objectID":"/filechannel/","tags":["jdk"],"title":"Filechannel 源码分析","uri":"/filechannel/"},{"categories":["documentation"],"content":"我们以FileOutputStream的getChannel为例: public FileChannel getChannel() { synchronized (this) { if (channel == null) { channel = FileChannelImpl.open(fd, path, false, true, append, this); } return channel; } } FileChannel类图: 有几点值得注意: InputStream和OutputStream不是线程安全的，而通道(Channel)是线程安全的。 Channel根据注释的解释，是一组IO操作的联结。 GatheringByteChannel，顾名思义就是将一组ByteBuffer的数据收集/组合起来，所以它继承自WritableByteChannel。 ScatteringByteChannel，即将一个通道的数据分散到多个ByteBuffer之中。 其实FileChannelImpl便是FileChannel的子类，位于包sun.nio.ch中，其源码可以从openjdk的jdk\\src\\share\\classes\\sun\\nio\\ch目录找到，open方法源码: public static FileChannel open(FileDescriptor fd, String path, boolean readable, boolean writable, boolean append, Object parent) { return new FileChannelImpl(fd, path, readable, writable, append, parent); } 可以看出，getChannel的原理就是构造了一个FileChannelImpl对象，此对象中保存有对应的流的是否可读、追加、文件描述符等属性。 从这里也可以看出，从输出流获取的通道由于readable被设为false，所以这个通道也就变成了不可读的。 写 FileChannelImpl.write简略版源码: public int write(ByteBuffer src) throws IOException { ensureOpen(); synchronized (positionLock) { int n = 0; int ti = -1; try { begin(); ti = threads.add(); if (!isOpen()) return 0; do { n = IOUtil.write(fd, src, -1, nd); } while ((n == IOStatus.INTERRUPTED) \u0026\u0026 isOpen()); return IOStatus.normalize(n); } finally { threads.remove(ti); end(n \u003e 0); assert IOStatus.check(n); } } } 实际上从这里我们可以看出通道的可中断是怎样实现的(IO流并不可以被中断)。begin方法在父类AbstractInterruptibleChannel中实现: protected final void begin() { if (interruptor == null) { interruptor = new Interruptible() { public void interrupt(Thread target) { synchronized (closeLock) { if (!open) return; open = false; interrupted = target; try { AbstractInterruptibleChannel.this.implCloseChannel(); } catch (IOException x) { } } }}; } blockedOn(interruptor); Thread me = Thread.currentThread(); if (me.isInterrupted()) interruptor.interrupt(me); } blockedOn实际上调用的是Thread的blockedOn方法: void blockedOn(Interruptible b) { synchronized (blockerLock) { blocker = b; } } 当所在线程被中断时，blocker对象的interrupt方法将会被调用，结合上面begin方法的实现，即当发生中断时，blocker将会关闭通道，这样也就退出了阻塞。Interruptible接口定义在sun.nio.ch中，从Thread的blocker对象的注释中可以看出，此对象是专门为实现可中断的IO而设置的。 IOUtil.write的调用全部发生在sun包内，我们忽略复杂的调用关系，看一下本质: FileDispatcherImpl.c的Java_sun_nio_ch_FileDispatcherImpl_write0方法实现(简略版): JNIEXPORT jint JNICALL Java_sun_nio_ch_FileDispatcherImpl_write0(JNIEnv *env, jclass clazz, jobject fdo, jlong address, jint len, jboolean append) { result = WriteFile(h, /* File handle to write */ (LPCVOID)address, /* pointers to the buffers */ len, /* number of bytes to write */ \u0026written, /* receives number of bytes written */ lpOv); /* overlapped struct */ return convertReturnVal(env, (jint)written, JNI_FALSE); } 所以，通过FileOutputStream还是FileChannel进行数据的写入，在系统层面都是一样的。 但是要注意，不同于OutputStream的write方法，这里的返回值是int。也就是说，通道的write方法并不保证一定将我们给定的数据一次性写出，正确的写姿势应该是这样的: while (buf.hasRemaining()) { channel.write(buf); } 那么问题来了，既然通道和OutputStream是使用的同一个系统级API，那么后者是怎么实现的? 玄机在于jdk\\src\\share\\native\\java\\io\\io_util.c的writeBytes方法其实已经帮我们实现了循环过程，关键源码: while (len \u003e 0) { fd = GET_FD(this, fid); if (fd == -1) { JNU_ThrowIOException(env, \"Stream Closed\"); break; } if (append == JNI_TRUE) { n = IO_Append(fd, buf+off, len); } else { n = IO_Write(fd, buf+off, len); } if (n == -1) { JNU_ThrowIOExceptionWithLastError(env, \"Write error\"); break; } off += n; len -= n; } 读 IOUtil.read源码: static int read(FileDescriptor fd, ByteBuffer dst, long position, NativeDispatcher nd) { if (dst instanceof DirectBuffer) return readIntoNativeBuffer(fd, dst, position, nd); // Substitute a native buffer ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining()); try { int n = readIntoNativeBuffer(fd, bb, position, nd); bb.flip(); if (n \u003e 0) dst.put(bb); return n; } finally { Util.offerFirstTemporaryDirectBuffer(bb); } } 从这里可以看到一个有意思的问题，如果传入的Buffer不是direct buffer，那么先将数据读取到一个direct buffer，再全部拷贝到给定的buffer中，写其实也是这样的，这么做是为了填jvm实现的坑，参考知乎R大的回答: Java NIO中，关于DirectBuffer，HeapBuffer的疑问？ FileDispatcherImpl.c的Java_sun_nio_ch_FileDispatcherImpl_read0关键源码: JNIEXPORT jint JNICALL Java_sun_nio_ch_FileDispatcherImpl_read0(JNIEnv *env, jclass ","date":"2021-06-07","objectID":"/filechannel/:0:0","tags":["jdk"],"title":"Filechannel 源码分析","uri":"/filechannel/"},{"categories":["documentation"],"content":"规则检查 此部分对应上表的map规则，相应源码: if ((mode != MapMode.READ_ONLY) \u0026\u0026 !writable) throw new NonWritableChannelException(); if (!readable) throw new NonReadableChannelException(); ","date":"2021-06-07","objectID":"/filechannel/:1:0","tags":["jdk"],"title":"Filechannel 源码分析","uri":"/filechannel/"},{"categories":["documentation"],"content":"大小检查 long filesize; do { filesize = nd.size(fd); } while ((filesize == IOStatus.INTERRUPTED) \u0026\u0026 isOpen()); if (!isOpen()) return null; //如果需要的大小大于实际的文件大小，那么对文件进行虚扩大 if (filesize \u003c position + size) { // Extend file size if (!writable) { throw new IOException(\"Channel not open for writing \" + \"- cannot extend file to required size\"); } int rv; do { rv = nd.truncate(fd, position + size); } while ((rv == IOStatus.INTERRUPTED) \u0026\u0026 isOpen()); if (!isOpen()) return null; } //需要的大小为0，返回一个逗你玩的buffer if (size == 0) { addr = 0; // a valid file descriptor is not required FileDescriptor dummy = new FileDescriptor(); if ((!writable) || (imode == MAP_RO)) return Util.newMappedByteBufferR(0, 0, dummy, null); else return Util.newMappedByteBuffer(0, 0, dummy, null); } ","date":"2021-06-07","objectID":"/filechannel/:2:0","tags":["jdk"],"title":"Filechannel 源码分析","uri":"/filechannel/"},{"categories":["documentation"],"content":"映射 int pagePosition = (int)(position % allocationGranularity); long mapPosition = position - pagePosition; long mapSize = size + pagePosition; addr = map0(imode, mapPosition, mapSize); FileDescriptor mfd = nd.duplicateForMapping(fd); int isize = (int)size; Unmapper um = new Unmapper(addr, mapSize, isize, mfd); if ((!writable) || (imode == MAP_RO)) { return Util.newMappedByteBufferR(isize, addr + pagePosition, mfd, um); } else { return Util.newMappedByteBuffer(isize, addr + pagePosition, mfd, um); } map0的linux实现由系统调用mmap完成，返回映射文件的内存地址。duplicateForMapping用于复制句柄，在Windows上需要这么做，但在linux上不需要。 Util.newMappedByteBuffer(R)方法实际上是构造了一个direct buffer，buffer的起始地址便是mmap返回的内存地址。 文件锁 我们以方法: public abstract FileLock lock(long position, long size, boolean shared); 为例，参数position和size的作用是lock方法允许我们针对文件的某一部分进行锁定，shared参数用以控制获取的是共享锁还是排它锁，默认锁定(即无参数lock方法)全部文件、排它锁。 文件锁是针对进程(即一个JVM虚拟机)而言的，所以如果当前JVM已拥有文件的锁，而此JVM的另一个线程又尝试获取锁(同一个文件，有重复的区域)，那么会抛出OverlappingFileLockException(共享锁、排它锁都会抛出)，这是符合逻辑的，因为同一个JVM内的多个线程之间安全性应该由程序自己维护，而不是文件锁。 以上提到的特性很容易利用以下代码进行验证，假设有线程如下: private static class GETLock implements Runnable { private final FileChannel channel; private final int start; private final int end; private GETLock(FileChannel channel, int start, int end) { this.channel = channel; this.start = start; this.end = end; } @Override public void run() { FileLock lock = channel.lock(start, end, true); System.out.println(Thread.currentThread().getName() + \"获得锁\"); Thread.sleep(2000); lock.release(); } } 验证代码: File file = new File(\"test\"); FileChannel channel = new RandomAccessFile(file, \"rw\").getChannel(); new Thread(new GETLock(channel, 0, 2)).start(); new Thread(new GETLock(channel, 1, 3)).start(); 只要文件区域出现重复，便会抛出异常。 FileLock位于nio包，类图: Java层面的实现位于FileChannelImpl.lock，下面对其进行分部分说明。 ","date":"2021-06-07","objectID":"/filechannel/:3:0","tags":["jdk"],"title":"Filechannel 源码分析","uri":"/filechannel/"},{"categories":["documentation"],"content":"逻辑验证 if (shared \u0026\u0026 !readable) throw new NonReadableChannelException(); if (!shared \u0026\u0026 !writable) throw new NonWritableChannelException(); 很容易理解，共享锁即读锁，如果获取到的通道不能读那么共享锁也就没有意义了 ，每种通道分别可以获得何种锁整理如下表: 类名 FileInputStream FileOutputStream RandomAccessFile 可获得的锁 共享锁 排它锁 全部 ","date":"2021-06-07","objectID":"/filechannel/:4:0","tags":["jdk"],"title":"Filechannel 源码分析","uri":"/filechannel/"},{"categories":["documentation"],"content":"FileLockTable 如上文所述，文件锁的作用域为整个虚拟机，也就是说，两个channel如果对同一个文件的重复区域进行加锁，势必会导致OverlappingFileLockException，那么Java是如何在整个虚拟机范围(全局)进行检查的呢?答案便是FileLockTable。 其位于sun.nio.ch下，类图: 相关源码: FileLockImpl fli = new FileLockImpl(this, position, size, shared); FileLockTable flt = fileLockTable(); flt.add(fli); fileLockTable方法决定采用FileLockTable的哪一个实现类: private FileLockTable fileLockTable() throws IOException { if (fileLockTable == null) { synchronized (this) { if (fileLockTable == null) { if (isSharedFileLockTable()) { fileLockTable = FileLockTable.newSharedFileLockTable(this, fd); } else { fileLockTable = new SimpleFileLockTable(); } } } } return fileLockTable; } 这里使用了一个双重检查，当然fileLockTable是volatile的。核心在于isSharedFileLockTable方法: private static boolean isSharedFileLockTable() { if (!propertyChecked) { synchronized (FileChannelImpl.class) { if (!propertyChecked) { String value = AccessController.doPrivileged( new GetPropertyAction( \"sun.nio.ch.disableSystemWideOverlappingFileLockCheck\")); isSharedFileLockTable = ((value == null) || value.equals(\"false\")); propertyChecked = true; } } } return isSharedFileLockTable; } 可以看出，这里其实是根据属性disableSystemWideOverlappingFileLockCheck来决定是否采用全局模式，当然value默认为null. 那么SharedFileLockTable又是如何保证的呢?玄机就在于其保存文件锁的载体: private static ConcurrentHashMap\u003cFileKey, List\u003cFileLockReference\u003e\u003e lockMap = new ConcurrentHashMap\u003cFileKey, List\u003cFileLockReference\u003e\u003e(); 静态。map的key为FileKey对象，由SharedFileLockTable的构造器创建: SharedFileLockTable(Channel channel, FileDescriptor fd) { this.channel = channel; this.fileKey = FileKey.create(fd); } FileKey是平台相关的，我们来看一下Linux的实现，类图: st_dev是所在设备的ID，st_ino是文件的inode号，静态方法create完成了native方法init的调用: JNIEXPORT void JNICALL Java_sun_nio_ch_FileKey_init(JNIEnv *env, jobject this, jobject fdo) { struct stat64 fbuf; int res; RESTARTABLE(fstat64(fdval(env, fdo), \u0026fbuf), res); if (res \u003c 0) { JNU_ThrowIOExceptionWithLastError(env, \"fstat64 failed\"); } else { //设置st_dev和st_ino (*env)-\u003eSetLongField(env, this, key_st_dev, (jlong)fbuf.st_dev); (*env)-\u003eSetLongField(env, this, key_st_ino, (jlong)fbuf.st_ino); } } fstat64就是fstat函数，为Linux下的系统调用，用以获得文件的相关信息。 map的value中FileLockReference为对FileLock的弱引用。 到这里SharedFileLockTable的add方法的逻辑就很容易想到了: 如果map中不存在此文件的记录，添加之，如果存在，检查是否有区域重复。 重复性检查由SharedFileLockTable的checkList完成，源码: private void checkList(List\u003cFileLockReference\u003e list, long position, long size) { for (FileLockReference ref: list) { FileLock fl = ref.get(); if (fl != null \u0026\u0026 fl.overlaps(position, size)) throw new OverlappingFileLockException(); } } FileLock.overlaps: public final boolean overlaps(long position, long size) { if (position + size \u003c= this.position) return false; // That is below this if (this.position + this.size \u003c= position) return false; // This is below that return true; } 一目了然。 ","date":"2021-06-07","objectID":"/filechannel/:5:0","tags":["jdk"],"title":"Filechannel 源码分析","uri":"/filechannel/"},{"categories":["documentation"],"content":"加锁 native方法Java_sun_nio_ch_FileDispatcherImpl_lock0完成，linux实现由函数fcntl完成，可以参考: linux 文件记录锁详解 size 用以获取文件的大小，Linux实现和FileKey的init方法一样，由fstat完成，注意File的length方法的Linux实现由stat完成。而stat和fstat的主要区别是后者的第一个参数为文件描述符(只有打开了文件才会有)，而前者的第一个参数是绝对的路径，不要求打开文件，这就和Java里两者的区别很好的印证。 关闭 FileChannel继承自AbstractInterruptibleChannel，通道关闭有此类实现，包括Socket通道也是如此: public final void close() { synchronized (closeLock) { if (!open) return; open = false; implCloseChannel(); } } implCloseChannel方法由FileChannelImpl实现: protected void implCloseChannel() throws IOException { // Release and invalidate any locks that we still hold if (fileLockTable != null) { for (FileLock fl: fileLockTable.removeAll()) { synchronized (fl) { if (fl.isValid()) { nd.release(fd, fl.position(), fl.size()); ((FileLockImpl)fl).invalidate(); } } } } threads.signalAndWait(); if (parent != null) { ((java.io.Closeable)parent).close(); } else { nd.close(fd); } } 分为如下几步: 线程唤醒, 在Linux上如果有线程阻塞在一个文件描述符上，那么即使此文件描述符(FD)被关闭，被阻塞的线程也不会被唤醒， threads.signalAndWait(); 正是用于将这些线程手动唤醒，threads是一个NativeThreadSet类型，在任何IO操作(比如write方法)前被加入，这一点可以在第一节\"写\"中得到验证。 清除文件锁表 调用依赖的资源的close方法。 关于唤醒线程安全这一点，其实有一个隐含的线程安全的问题，结合read方法源码: public int read(ByteBuffer dst) throws IOException { ensureOpen(); if (!readable) throw new NonReadableChannelException(); synchronized (positionLock) { int n = 0; int ti = -1; try { begin(); ti = threads.add(); if (!isOpen()) return 0; //here! do { n = IOUtil.read(fd, dst, -1, nd); } while ((n == IOStatus.INTERRUPTED) \u0026\u0026 isOpen()); return IOStatus.normalize(n); } finally { threads.remove(ti); end(n \u003e 0); assert IOStatus.check(n); } } } 如果进行通道关闭的线程唤醒被阻塞的线程、关闭文件描述符这一过程在读线程的最后一次isOpen检查和read调用之间完成(即上面源码中here处)完成，由于内核会对文件描述符进行回收(重用)，这样完全会导致read操作读取的是一个全新的文件描述符! JDK解决的办法在于NativeThreadSet.signalAndWait中(简略版): void signalAndWait() { synchronized (this) { while (used \u003e 0) { try { wait(); } catch (InterruptedException e) { interrupted = true; } } } } used表示正在进行读写的线程数，可以看出，只要尚有线程正在进行读写操作，关闭线程就会阻塞。那什么时候被唤醒呢?remove方法源码: void remove(int i) { synchronized (this) { elts[i] = 0; used--; if (used == 0 \u0026\u0026 waitingToEmpty) notifyAll(); } } 这就保证了当进行实际的文件描述符关闭时，一定没有正在读写的线程，这就杜绝了上述情况的发生。 ","date":"2021-06-07","objectID":"/filechannel/:6:0","tags":["jdk"],"title":"Filechannel 源码分析","uri":"/filechannel/"},{"categories":["documentation"],"content":"HashMap 源码分析.","date":"2021-06-01","objectID":"/hashmap/","tags":["jdk"],"title":"HashMap 源码分析","uri":"/hashmap/"},{"categories":["documentation"],"content":"类图如下: 构造 我们以无参构造器为例: public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 其它的参数均取默认。 put public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } putVal源码: final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; //1.初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //2.bin为null，初始化第一个节点 if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) //指定key的值已存在，那么记录下原先的值 e = p; else if (p instanceof TreeNode) //红黑树 e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); else { //bin不为空，且与链表头不相同(==或equals) //3. for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //达到临界值转为红黑树 if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //空实现，为LinkedHashMap预留 afterNodeAccess(e); return oldValue; } } ++modCount; //4. if (++size \u003e threshold) resize(); //空实现，为LinkedHashMap预留 afterNodeInsertion(evict); return null; } onlyIfAbsent参数如果为true，那么对于已经存在的key，将不替换其值 。table即HashMap进行数据存储的核心变量: transient Node\u003cK,V\u003e[] table; Node代表了table中的一项，类图: ","date":"2021-06-01","objectID":"/hashmap/:0:0","tags":["jdk"],"title":"HashMap 源码分析","uri":"/hashmap/"},{"categories":["documentation"],"content":"哈希算法 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16); } 这里在原生hashCode的基础上做了一次与高16位相异或的处理，这样做的目的是将哈希值的高位纳入到取余运算中来，防止由于低位相同造成的频繁冲突的情况。 ","date":"2021-06-01","objectID":"/hashmap/:1:0","tags":["jdk"],"title":"HashMap 源码分析","uri":"/hashmap/"},{"categories":["documentation"],"content":"表头还是表尾 当bin中已含有节点链表，且要插入新的元素时从表头还是表尾插入? 从源码(3)中很明显可以看出是从表尾插入，因为HashMap需要判断链表中元素的个数以决定是否将其转为红黑树。 ","date":"2021-06-01","objectID":"/hashmap/:2:0","tags":["jdk"],"title":"HashMap 源码分析","uri":"/hashmap/"},{"categories":["documentation"],"content":"size HashMap中维护有一个字段size记录当前元素的个数: transient int size; 从上面putVal方法源码(4)中可以看到其改变方式。 get public V get(Object key) { Node\u003cK,V\u003e e; return (e = getNode(hash(key), key)) == null ? null : e.value; } 剩下的脑补即可。 resize final Node\u003cK,V\u003e[] resize() { Node\u003cK,V\u003e[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //原table不为null， if (oldCap \u003e 0) { //MAXIMUM_CAPACITY取1 \u003c\u003c 30，即table数组的大小，如果已到达此值，那么无需扩容 if (oldCap \u003e= MAXIMUM_CAPACITY) { //threshold，CAPACITY乘以负载因子即扩容的临界值 threshold = Integer.MAX_VALUE; return oldTab; } //没有达到最大值，两倍扩容 else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 oldCap \u003e= DEFAULT_INITIAL_CAPACITY) newThr = oldThr \u003c\u003c 1; // double threshold } else if (oldThr \u003e 0) // initial capacity was placed in threshold newCap = oldThr; else { //初始化，默认大小为16 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j \u003c oldCap; ++j) { Node\u003cK,V\u003e e; if ((e = oldTab[j]) != null) { //数组的此位置含有元素 oldTab[j] = null; if (e.next == null) //如果桶位中只有一个元素=\u003e直接设置 newTab[e.hash \u0026 (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap); else { // preserve order Node\u003cK,V\u003e loHead = null, loTail = null; Node\u003cK,V\u003e hiHead = null, hiTail = null; Node\u003cK,V\u003e next; do { next = e.next; if ((e.hash \u0026 oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } ","date":"2021-06-01","objectID":"/hashmap/:3:0","tags":["jdk"],"title":"HashMap 源码分析","uri":"/hashmap/"},{"categories":["documentation"],"content":"移动 我们在guava-cache中已经见识过了，假设map的最初容量为8，现要扩容到16，实际上对于每一个桶位(bin)，只有两种情况: 无需移动(bin下标不变)，比如hashCode为7的情况。 移动到原先下标位置 + 最初容量的位置，比如对于hashCode 12，原本为4，现在要移动至12，移动了8. 那么如何判断是否需要移动呢? 因为我们的容量都是2的整次幂，对8取余我们只要\u0026 (8 - 1)即可，所以8和16的mask分别为: 0111 1111 我们只需hashCode \u0026 8即可，这便是源码中preserve order部分所做的。 那么为什么要对一个bin中的每一个元素都要进行判断呢?因为比如对于bin 4，在容量为8的情况下，hashCode为4和12都会进入到这个位置，而扩容后就不一定了。 红黑树 其时间复杂度为O(logn)，不再详细探究其细节，可参考: 教你初步了解红黑树 containsValue 查询是否包含特定的key较为简单，等同于一次get操作，而查询value则不是: public boolean containsValue(Object value) { Node\u003cK,V\u003e[] tab; V v; if ((tab = table) != null \u0026\u0026 size \u003e 0) { for (int i = 0; i \u003c tab.length; ++i) { for (Node\u003cK,V\u003e e = tab[i]; e != null; e = e.next) { if ((v = e.value) == value || (value != null \u0026\u0026 value.equals(v))) return true; } } } return false; } 这是一个遍历所有bin + 链表/红黑树的过程，所以有过有根据value查找key的需求我们可以使用双向Map，比如Guava的BiMap。 ","date":"2021-06-01","objectID":"/hashmap/:4:0","tags":["jdk"],"title":"HashMap 源码分析","uri":"/hashmap/"},{"categories":["documentation"],"content":"linux-基础常用操作以及概念.","date":"2021-06-01","objectID":"/linux-base/","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"linux-基础常用操作以及概念. ","date":"2021-06-01","objectID":"/linux-base/:0:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"引言 linux-基础 ","date":"2021-06-01","objectID":"/linux-base/:1:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"常用操作以及概念 ","date":"2021-06-01","objectID":"/linux-base/:2:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"快捷键 Tab: 命令和文件名补全； Ctrl+C: 中断正在运行的程序； Ctrl+D: 结束键盘输入(End Of File，EOF) ","date":"2021-06-01","objectID":"/linux-base/:2:1","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"求助 –help 指令的基本用法与选项介绍。 man man 是 manual 的缩写，将指令的具体信息显示出来。 info info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以进行跳转。 doc /usr/share/doc 存放着软件的一整套说明文件。 ","date":"2021-06-01","objectID":"/linux-base/:2:2","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"关机 who 在关机前需要先使用 who 命令查看有没有其它用户在线。 sync 为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。 shutdown ## shutdown [-krhc] 时间 [信息] -k : 不会关机，只是发送警告信息，通知所有在线的用户 -r : 将系统的服务停掉后就重新启动 -h : 将系统的服务停掉后就立即关机 -c : 取消已经在进行的 shutdown 指令内容 ","date":"2021-06-01","objectID":"/linux-base/:2:3","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"PATH 可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。 /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin ","date":"2021-06-01","objectID":"/linux-base/:2:4","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"sudo sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令. ","date":"2021-06-01","objectID":"/linux-base/:2:5","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"包管理工具 RPM 和 DPKG 为最常见的两类软件包管理工具: RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为很多 Linux 系统 (RHEL) 的既定软件标准。 与 RPM 进行竞争的是基于 Debian 操作系统 (Ubuntu) 的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。 YUM 基于 RPM，具有依赖管理功能，并具有软件升级的功能。 ","date":"2021-06-01","objectID":"/linux-base/:2:6","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"发行版 Linux 发行版是 Linux 内核及各种应用软件的集成版本。 基于的包管理工具 商业发行版 社区发行版 RPM Red Hat Fedora / CentOS DPKG Ubuntu Debian ","date":"2021-06-01","objectID":"/linux-base/:2:7","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"VIM 一般指令模式(Command mode): VIM 的默认模式，可以用于移动游标查看内容； 编辑模式(Insert mode): 按下 “i” 等按键之后进入，可以对文本进行编辑； 指令列模式(Bottom-line mode): 按下 “:” 按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。 命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 ","date":"2021-06-01","objectID":"/linux-base/:2:8","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"磁盘 ","date":"2021-06-01","objectID":"/linux-base/:3:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"磁盘接口 IDE IDE(ATA)全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。 SATA SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MiB/s，而新的 SATA-III 标准可达到 600MiB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。 SCSI SCSI 全称是 Small Computer System Interface(小型机系统接口)，经历多代的发展，从早期的 SCSI-II 到目前的 Ultra320 SCSI 以及 Fiber-Channel(光纤通道)，接口型式也多种多样。SCSI 硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。 SAS SAS(Serial Attached SCSI)是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也透过缩小连接线改善系统内部空间等。 ","date":"2021-06-01","objectID":"/linux-base/:3:1","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"分区 ","date":"2021-06-01","objectID":"/linux-base/:4:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"分区表 磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。 MBR MBR 中，第一个扇区最重要，里面有主要开机记录(Master boot record, MBR)及分区表(partition table)，其中主要开机记录占 446 bytes，分区表占 64 bytes。 分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区(Primary)和扩展分区(Extended)。其中扩展分区只有一个，它使用其它扇区用记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。 Linux 也把分区当成文件，分区文件的命名方式为: 磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。 GPT 不同的磁盘有不同的扇区大小，例如 512 bytes 和最新磁盘的 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址(Logical Block Address, LBA)，LBA 默认大小为 512 bytes。 GPT 第 1 个区块记录了主要开机记录(MBR)，紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。 GPT 没有扩展分区概念，都是主分区，每个 LAB 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。 MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 233 TB = 8 ZB。 ","date":"2021-06-01","objectID":"/linux-base/:4:1","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"开机检测程序 BIOS BIOS(Basic Input/Output System，基本输入输出系统)，它是一个固件(嵌入在硬件中的软件)，BIOS 程序存放在断电后内容不会丢失的只读内存中。 BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录(MBR)，由主要开机记录(MBR)执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。 主要开机记录(MBR)中的开机管理程序提供以下功能: 选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现了多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。 下图中，第一扇区的主要开机记录(MBR)中的开机管理程序提供了两个选单: M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。 安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录(MBR)，而 Linux 可以选择将开机管理程序安装在主要开机记录(MBR)或者其它分区的启动扇区，并且可以设置开机管理程序的选单。 UEFI BIOS 不可以读取 GPT 分区表，而 UEFI 可以。 ","date":"2021-06-01","objectID":"/linux-base/:4:2","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"文件系统 ","date":"2021-06-01","objectID":"/linux-base/:5:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"分区与文件系统 对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。 ","date":"2021-06-01","objectID":"/linux-base/:5:1","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"组成 最主要的几个组成部分如下: inode: 一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号； block: 记录文件的内容，文件太大时，会占用多个 block。 superblock: 记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等； block bitmap: 记录 block 是否被使用的位域。 ","date":"2021-06-01","objectID":"/linux-base/:5:2","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"文件读取 对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中去查找文件内容所在的所有 block，然后把所有 block 的内容读出来。 ","date":"2021-06-01","objectID":"/linux-base/:5:3","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"磁盘碎片 指一个文件内容所在的 block 过于分散。 ","date":"2021-06-01","objectID":"/linux-base/:5:4","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"Block 在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。 一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。 ","date":"2021-06-01","objectID":"/linux-base/:5:5","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"inode inode 具体包含以下信息: 权限 (read/write/excute)； 拥有者与群组 (owner/group)； 容量； 建立或状态改变的时间 (ctime)； 最近一次的读取时间 (atime)； 最近修改的时间 (mtime)； 定义文件特性的旗标 (flag)，如 SetUID…； 该文件真正内容的指向 (pointer)。 inode 具有以下特点: 每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)； 每个文件都仅会占用一个 inode。 inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用是指，让 inode 记录的引用 block 块记录引用信息。 ","date":"2021-06-01","objectID":"/linux-base/:5:6","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"目录 建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。 可以看出文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的 w 权限有关。 ","date":"2021-06-01","objectID":"/linux-base/:5:7","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"日志 如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。 ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。 ","date":"2021-06-01","objectID":"/linux-base/:5:8","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"挂载 挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。 ","date":"2021-06-01","objectID":"/linux-base/:5:9","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"目录配置 为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下: / (root, 根目录) /usr (unix software resource): 所有系统默认软件都会安装到这个目录； /var (variable): 存放系统或程序运行过程中的数据文件。 ","date":"2021-06-01","objectID":"/linux-base/:5:10","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"文件 ","date":"2021-06-01","objectID":"/linux-base/:6:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"文件属性 用户分为三种: 文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。 使用 ls 查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x. 3 root root 17 May 6 00:14 .config，对这个信息的解释如下: drwxr-xr-x: 文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 3: 链接数 root: 文件拥有者 root: 所属群组 17: 文件大小 May 6 00:14: 文件最后被修改的时间 .config: 文件名 常见的文件类型及其含义有: d: 目录 -: 文件 l: 链接文件 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。 文件时间有以下三种: modification time (mtime): 文件的内容更新就会更新； status time (ctime): 文件的状态(权限、属性)更新就会更新； access time (atime): 读取文件时就会更新。 ","date":"2021-06-01","objectID":"/linux-base/:6:1","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"文件与目录的基本操作 ls 列出文件或者目录的信息，目录的信息就是其中包含的文件。 ## ls [-aAdfFhilnrRSt] file|dir -a : 列出全部的文件 -d : 仅列出目录本身 -l : 以长数据串行列出，包含文件的属性与权限等等数据 cd 更新当前目录 cd [相对路径或者绝对路径] mkdir 创建目录 ## mkdir [-mp] 目录名称 -m : 配置目录权限 -p : 递归创建目录 rmdir 删除目录，目录必须为空 rmdir [-p] 目录名称 -p : 递归删除目录 touch 更新文件时间或者建立新文件 ## touch [-acdmt] filename -a : 更新 atime -c : 更新 ctime，若该文件不存在则不建立新文件 -m : 更新 mtime -d : 后面可以接更新日期而不使用当前日期，也可以使用 --date=\"日期或时间\" -t : 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] cp 复制文件 如果源文件有两个以上，则目的文件一定要是目录才行。 cp [-adfilprsu] source destination -a : 相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明 -d : 若来源文件为链接文件，则复制链接文件属性而非文件本身 -i : 若目标文件已经存在时，在覆盖前会先询问 -p : 连同文件的属性一起复制过去 -r : 递归持续复制 -u : destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制 --preserve=all : 除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 rm 删除文件 ## rm [-fir] 文件或目录 -r : 递归删除 mv 移动文件 ## mv [-fiu] source destination ## mv [options] source1 source2 source3 .... directory -f : force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 ","date":"2021-06-01","objectID":"/linux-base/:6:2","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"修改权限 可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 ## chmod [-R] xyz dirname/filename 示例: 将 .bashrc 文件的权限修改为 -rwxr-xr–。 ## chmod 754 .bashrc 也可以使用符号来设定权限。 ## chmod [ugoa] [+-=] [rwx] dirname/filename - u: 拥有者 - g: 所属群组 - o: 其他人 - a: 所有人 - +: 添加权限 - -: 移除权限 - =: 设定权限 示例: 为 .bashrc 文件的所有用户添加写权限。 ## chmod a+w .bashrc ","date":"2021-06-01","objectID":"/linux-base/:6:3","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"文件默认权限 文件默认权限: 文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。 目录默认权限: 目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 可以通过 umask 设置或者查看文件的默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。 ","date":"2021-06-01","objectID":"/linux-base/:6:4","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"目录的权限 文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。 目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。 ","date":"2021-06-01","objectID":"/linux-base/:6:5","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"链接 ## ln [-sf] source_filename dist_filename -s : 默认是 hard link，加 -s 为 symbolic link -f : 如果目标文件存在时，先删除目标文件 ","date":"2021-06-01","objectID":"/linux-base/:6:6","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"实体链接 在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。 删除任意一个条目，文件还是存在，只要引用数量不为 0。 有以下限制: 不能跨越文件系统、不能对目录进行链接。 ## ln /etc/crontab . ## ll -i /etc/crontab crontab 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab ","date":"2021-06-01","objectID":"/linux-base/:6:7","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"符号链接 符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。 当源文件被删除了，链接文件就打不开了。 可以为目录建立链接。 ## ll -i /etc/crontab /root/crontab2 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -\u003e /etc/crontab ","date":"2021-06-01","objectID":"/linux-base/:6:8","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"获取文件内容 cat 取得文件内容。 ## cat [-AbEnTv] filename -n : 打印出行号，连同空白行也会有行号，-b 不会 tac 是 cat 的反向操作，从最后一行开始打印。 more 和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。 less 和 more 类似，但是多了一个向前翻页的功能。 head 取得文件前几行。 ## head [-n number] filename -n : 后面接数字，代表显示几行的意思 tail 是head的反向操作，之水取得是后几行 od 以字符或者十六进制的形式显示二进制文件。 ","date":"2021-06-01","objectID":"/linux-base/:6:9","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"指令与文件搜索 which 指令搜索 ## which [-a] command -a : 将所有指令列出，而不是只列第一个 whereis 文件搜索。速度比较快，因为它只搜索几个特定的目录。 ## whereis [-bmsu] dirname/filename locate 文件搜索。可以用关键字或者正则表达式进行搜索。 locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 ## locate [-ir] keyword -r: 正则表达式 find 文件搜索。可以使用文件的属性和权限进行搜索。 ## find [basedir] [option] example: find . -name \"shadow*\" ","date":"2021-06-01","objectID":"/linux-base/:6:10","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"压缩与打包 ","date":"2021-06-01","objectID":"/linux-base/:7:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"压缩文件名 gzip gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。 经过 gzip 压缩过，源文件就不存在了。 有 9 个不同的压缩等级可以使用。 可以使用 zcat、zmore、zless 来读取压缩文件的内容。 $ gzip [-cdtv#] filename -c : 将压缩的数据输出到屏幕上 -d : 解压缩 -t : 检验压缩文件是否出错 -v : 显示压缩比等信息 -## : ## 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 bzip2 提供比 gzip 更高的压缩比。 查看命令: bzcat、bzmore、bzless、bzgrep。 xz 提供比 bzip2 更佳的压缩比。 可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。 查看命令: xzcat、xzmore、xzless、xzgrep。 ","date":"2021-06-01","objectID":"/linux-base/:7:1","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"打包 压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。 $ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩 $ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看 $ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩 -z : 使用 zip； -j : 使用 bzip2； -J : 使用 xz； -c : 新建打包文件； -t : 查看打包文件里面有哪些文件； -x : 解打包或解压缩的功能； -v : 在压缩/解压缩的过程中，显示正在处理的文件名； -f : filename: 要处理的文件； -C 目录 : 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 ","date":"2021-06-01","objectID":"/linux-base/:7:2","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"bash 可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。 ","date":"2021-06-01","objectID":"/linux-base/:8:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"特性 命令历史：记录使用过的命令 命令与文件补全：快捷键：tab shell scripts 通配符: 例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件 ","date":"2021-06-01","objectID":"/linux-base/:8:1","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"变量操作 对一个变量赋值直接使用 =。 对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式； 输出变量使用 echo 命令。 $ x=abc $ echo $x $ echo ${x} 变量内容如果有空格，必须使用双引号或者单引号。 双引号内的特殊字符可以保留原本特性，例如 x=“lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8； 单引号内的特殊字符就是特殊字符本身，例如 x=‘lang is $LANG’，则 x 的值为 lang is $LANG。 可以使用 指令 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。 可以使用 指令 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。 Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令: $ declare [-aixr] variable -a : 定义为数组类型 -i : 定义为整数类型 -x : 定义为环境变量 -r : 定义为 readonly 类型 对数组操作 $ array[1]=a $ array[2]=b $ echo ${array[1]} ","date":"2021-06-01","objectID":"/linux-base/:8:2","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"正则 g/re/p(globally search a regular expression and print)，使用正则表示式进行全局查找并打印。 $ grep [-acinv] [--color=auto] 搜寻字符串 filename -c : 统计个数 -i : 忽略大小写 -n : 输出行号 -v : 反向选择，也就是显示出没有 搜寻字符串 内容的那一行 --color=auto : 找到的关键字加颜色显示 示例: 把含有 the 字符串的行提取出来(注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串) $ grep -n 'the' regular_express.txt 8:I can't finish the test. 12:the symbol '*' is represented as start. 15:You are the best is mean you are the no. 1. 16:The world Happy is the same with \"glad\". 18:google is the best tools for search keyword ","date":"2021-06-01","objectID":"/linux-base/:9:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"进程管理 ","date":"2021-06-01","objectID":"/linux-base/:10:0","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"查看进程 ps 查看某个时间点的进程信息 示例一: 查看自己的进程ps -l 示例二: 查看系统所有进程ps aux 示例三: 查看特定的进程ps aux | grep python top 实时显示进程信息 示例: 两秒钟刷新一次top -d 2 pstree 查看进程树 示例: 查看所有进程树pstree -A netstat 查看占用端口的进程 示例: 查看特定端口的进程netstat -anp | grep port ","date":"2021-06-01","objectID":"/linux-base/:10:1","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"孤儿进程 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。 孤儿进程将被init进程（进程号为1）所收养，并有init进程对它们完成状态收集工作。 由于孤儿进程会被init进程收养，所以孤儿进程不会对系统造成危害。 ","date":"2021-06-01","objectID":"/linux-base/:10:2","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["documentation"],"content":"僵尸进程 一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过wait()或者waitpid()获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用wait()或waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。 僵尸进程通过 ps 命令显示出来的状态为 Z(zombie)。 系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。 ","date":"2021-06-01","objectID":"/linux-base/:10:3","tags":["linux"],"title":"linux-基础","uri":"/linux-base/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意\r\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. \r\r 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r\r 将此页保存为书签，以备将来参考!\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments\rline 1 of code\rline 2 of code\rline 3 of code\r 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\r\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \"\rThe Dojocat\r 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\r\rLoveIt 主题提供了一个包含更多功能的 图片的 shortcode.\r\r 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"/emoji-support/","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01","objectID":"/emoji-support/:0:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"表情与情感 ","date":"2019-10-01","objectID":"/emoji-support/:1:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"/emoji-support/:1:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"/emoji-support/:1:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"/emoji-support/:1:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"/emoji-support/:1:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"/emoji-support/:1:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"/emoji-support/:1:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"/emoji-support/:1:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"/emoji-support/:1:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"/emoji-support/:1:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"/emoji-support/:1:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"/emoji-support/:1:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"/emoji-support/:1:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"/emoji-support/:1:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"/emoji-support/:1:14","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"/emoji-support/:1:15","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"人与身体 ","date":"2019-10-01","objectID":"/emoji-support/:2:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"/emoji-support/:2:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"/emoji-support/:2:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"/emoji-support/:2:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"/emoji-support/:2:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"/emoji-support/:2:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"/emoji-support/:2:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"/emoji-support/:2:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"/emoji-support/:2:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"/emoji-support/:2:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"/emoji-support/:2:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"/emoji-support/:2:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"/emoji-support/:2:14","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 👩‍❤️‍👨 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"/emoji-support/:2:15","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"/emoji-support/:2:16","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"动物与自然 ","date":"2019-10-01","objectID":"/emoji-support/:3:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"/emoji-support/:3:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"/emoji-support/:3:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"/emoji-support/:3:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"/emoji-support/:3:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"/emoji-support/:3:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"/emoji-support/:3:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"/emoji-support/:3:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"/emoji-support/:3:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"食物与饮料 ","date":"2019-10-01","objectID":"/emoji-support/:4:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"/emoji-support/:4:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"/emoji-support/:4:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"/emoji-support/:4:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"/emoji-support/:4:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"/emoji-support/:4:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"/emoji-support/:4:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"/emoji-support/:4:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"/emoji-support/:4:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"旅游与地理 ","date":"2019-10-01","objectID":"/emoji-support/:5:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"/emoji-support/:5:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"/emoji-support/:5:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"/emoji-support/:5:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"/emoji-support/:5:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"/emoji-support/:5:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"/emoji-support/:5:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"/emoji-support/:5:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"/emoji-support/:5:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"/emoji-support/:5:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"/emoji-support/:5:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"/emoji-support/:5:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"活动 ","date":"2019-10-01","objectID":"/emoji-support/:6:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"/emoji-support/:6:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"/emoji-support/:6:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"/emoji-support/:6:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"/emoji-support/:6:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"/emoji-support/:6:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"物品 ","date":"2019-10-01","objectID":"/emoji-support/:7:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"/emoji-support/:7:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"/emoji-support/:7:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"/emoji-support/:7:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"/emoji-support/:7:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"/emoji-support/:7:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"/emoji-support/:7:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"/emoji-support/:7:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"/emoji-support/:7:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"/emoji-support/:7:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"/emoji-support/:7:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"/emoji-support/:7:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"/emoji-support/:7:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"/emoji-support/:7:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"/emoji-support/:7:14","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"/emoji-support/:7:15","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"/emoji-support/:7:16","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"/emoji-support/:7:17","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"/emoji-support/:7:18","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"符号 ","date":"2019-10-01","objectID":"/emoji-support/:8:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"/emoji-support/:8:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"/emoji-support/:8:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"/emoji-support/:8:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"/emoji-support/:8:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"/emoji-support/:8:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"/emoji-support/:8:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"/emoji-support/:8:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"/emoji-support/:8:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"/emoji-support/:8:11","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"/emoji-support/:8:12","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"/emoji-support/:8:13","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"旗帜 ","date":"2019-10-01","objectID":"/emoji-support/:9:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"/emoji-support/:9:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Markdown"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"/emoji-support/:9:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"}]